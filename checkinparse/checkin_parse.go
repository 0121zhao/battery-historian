// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//Package checkinparse contains functions to parse checkin report into batterystats proto.
package checkinparse

import (
	"errors"
	"fmt"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/golang/protobuf/proto"

	"github.com/google/battery-historian/build"
	"github.com/google/battery-historian/checkinutil"
	"github.com/google/battery-historian/packageutils"
	"github.com/google/battery-historian/sliceparse"

	bspb "github.com/google/battery-historian/pb/batterystats_proto"
	sessionpb "github.com/google/battery-historian/pb/session_proto"
	usagepb "github.com/google/battery-historian/pb/usagestats_proto"
)

const (
	// number of fields charge and discharge step data have
	numStepFields = 8
	// minimum number of fields any type of battery stats have
	minNumFields = 4
	// Current range of supported/expected versions
	minParseReportVersion = 11
	maxParseReportVersion = 14
)

// Possible battery stats categories generated by on device java code.
const (
	packageInfo  = "i"
	sinceCharged = "l" // SINCE_CHARGED: Since last charged: The only reliable value.
	current      = "c" // Deprecated
	unplugged    = "u" // Deprecated: SINCE_UNPLUGGED: Very unreliable and soon to be removed.
)

// String representations of categories the parsing code handles. Contains all
// categories defined in frameworks/base/core/java/android/os/BatteryStats.java
// unless explicitly stated.
const (
	versionData          = "vers"
	uidData              = "uid"
	apkData              = "apk"
	processData          = "pr"
	sensorData           = "sr"
	vibratorData         = "vib"
	foregroundData       = "fg"
	stateTimeData        = "st"
	wakelockData         = "wl"
	syncData             = "sy"
	jobData              = "jb"
	kernelWakelockData   = "kwl"
	wakeupReasonData     = "wr"
	networkData          = "nt"
	userActivityData     = "ua"
	batteryData          = "bt"
	batteryDischargeData = "dc"
	batteryLevelData     = "lv"
	GlobalWifiData       = "gwfl"
	wifiData             = "wfl"
	GlobalBluetoothData  = "gble"
	miscData             = "m"
	globalNetworkData    = "gn"
	// HISTORY_STRING_POOL (hsp) is not included in the checkin log.
	// HISTORY_DATA (h) is not included in the checkin log.
	screenBrightnessData        = "br"
	signalStrengthTimeData      = "sgt"
	signalScanningTimeData      = "sst"
	signalStrengthCountData     = "sgc"
	dataConnectionTimeData      = "dct"
	dataConnectionCountData     = "dcc"
	wifiStateTimeData           = "wst"
	wifiStateCountData          = "wsc"
	wifiSupplStateTimeData      = "wsst"
	wifiSupplStateCountData     = "wssc"
	wifiSignalStrengthTimeData  = "wsgt"
	wifiSignalStrengthCountData = "wsgc"
	bluetoothStateTimeData      = "bst"
	bluetoothStateCountData     = "bsc"
	powerUseSummaryData         = "pws"
	powerUseItemData            = "pwi"
	dischargeStepData           = "dsd"
	chargeStepData              = "csd"
	dischargeTimeRemainData     = "dtr"
	chargeTimeRemainData        = "ctr"
)

var (
	powerUseItemNameMap = map[string]bspb.BatteryStats_System_PowerUseItem_Name{
		"idle":       bspb.BatteryStats_System_PowerUseItem_IDLE,
		"cell":       bspb.BatteryStats_System_PowerUseItem_CELL,
		"phone":      bspb.BatteryStats_System_PowerUseItem_PHONE,
		"wifi":       bspb.BatteryStats_System_PowerUseItem_WIFI,
		"blue":       bspb.BatteryStats_System_PowerUseItem_BLUETOOTH,
		"scrn":       bspb.BatteryStats_System_PowerUseItem_SCREEN,
		"uid":        bspb.BatteryStats_System_PowerUseItem_APP,
		"user":       bspb.BatteryStats_System_PowerUseItem_USER,
		"unacc":      bspb.BatteryStats_System_PowerUseItem_UNACCOUNTED,
		"over":       bspb.BatteryStats_System_PowerUseItem_OVERCOUNTED,
		"???":        bspb.BatteryStats_System_PowerUseItem_DEFAULT,
		"flashlight": bspb.BatteryStats_System_PowerUseItem_FLASHLIGHT,
	}

	// Contains a mapping of known packages with their shared UIDs. Common shared UIDs
	// were found by looking at aggregate checkin data and confirming with code search.
	// Check go/android-uids for a non-exhaustive list.
	packageNameToSharedUIDMap = map[string]string{
		// com.google.uid.shared
		"com.google.android.apps.gtalkservice":     "GOOGLE_SERVICES",
		"com.google.android.backuptransport":       "GOOGLE_SERVICES",
		"com.google.android.gms":                   "GOOGLE_SERVICES",
		"com.google.android.gms.car.userfeedback":  "GOOGLE_SERVICES",
		"com.google.android.googleapps":            "GOOGLE_SERVICES",
		"com.google.android.gsf":                   "GOOGLE_SERVICES",
		"com.google.android.gsf.login":             "GOOGLE_SERVICES",
		"com.google.android.gsf.notouch":           "GOOGLE_SERVICES",
		"com.google.android.providers.gmail":       "GOOGLE_SERVICES",
		"com.google.android.sss.authbridge":        "GOOGLE_SERVICES",
		"com.google.android.syncadapters.contacts": "GOOGLE_SERVICES",
		"com.google.gch.gateway":                   "GOOGLE_SERVICES",

		// com.google.android.calendar.uid.shared
		"com.android.calendar":                     "GOOGLE_CALENDAR",
		"com.google.android.calendar":              "GOOGLE_CALENDAR",
		"com.google.android.syncadapters.calendar": "GOOGLE_CALENDAR",

		// android.uid.system
		"android":                            "ANDROID_SYSTEM",
		"com.android.changesettings":         "ANDROID_SYSTEM",
		"com.android.inputdevices":           "ANDROID_SYSTEM",
		"com.android.keychain":               "ANDROID_SYSTEM",
		"com.android.location.fused":         "ANDROID_SYSTEM",
		"com.android.providers.settings":     "ANDROID_SYSTEM",
		"com.android.settings":               "ANDROID_SYSTEM",
		"com.google.android.canvas.settings": "ANDROID_SYSTEM",
		"com.lge.SprintHiddenMenu":           "ANDROID_SYSTEM",
		"com.nvidia.tegraprofiler.security":  "ANDROID_SYSTEM",
		"com.qualcomm.atfwd":                 "ANDROID_SYSTEM",
		"com.qualcomm.display":               "ANDROID_SYSTEM",

		// android.uid.phone
		"com.android.phone":                    "PHONE",
		"com.android.providers.telephony":      "PHONE",
		"com.android.sdm.plugins.connmo":       "PHONE",
		"com.android.sdm.plugins.dcmo":         "PHONE",
		"com.android.sdm.plugins.sprintdm":     "PHONE",
		"com.htc.android.qxdm2sd":              "PHONE",
		"com.android.mms.service":              "PHONE",
		"com.android.server.telecom":           "PHONE",
		"com.android.sprint.lifetimedata":      "PHONE",
		"com.android.stk":                      "PHONE",
		"com.motorola.service.ims":             "PHONE",
		"com.qualcomm.qti.imstestrunner":       "PHONE",
		"com.qualcomm.qti.rcsbootstraputil":    "PHONE",
		"com.qualcomm.qti.rcsimsbootstraputil": "PHONE",
		"com.qualcomm.qcrilmsgtunnel":          "PHONE",
		"com.qualcomm.shutdownlistner":         "PHONE",
		"org.codeaurora.ims":                   "PHONE",
		"com.asus.atcmd":                       "PHONE",
		"com.mediatek.imeiwriter":              "PHONE",

		// android.uid.nfc
		"com.android.nfc":                 "NFC",
		"com.android.nfc3":                "NFC",
		"com.google.android.uiccwatchdog": "NFC",

		// android.uid.shared
		"com.android.contacts":                 "CONTACTS_PROVIDER",
		"com.android.providers.applications":   "CONTACTS_PROVIDER",
		"com.android.providers.contacts":       "CONTACTS_PROVIDER",
		"com.android.providers.userdictionary": "CONTACTS_PROVIDER",

		// android.media
		"com.android.gallery":                "MEDIA",
		"com.android.providers.downloads":    "MEDIA",
		"com.android.providers.downloads.ui": "MEDIA",
		"com.android.providers.drm":          "MEDIA",
		"com.android.providers.media":        "MEDIA",

		// android.uid.systemui
		"com.android.keyguard": "SYSTEM_UI",
		"com.android.systemui": "SYSTEM_UI",

		// android.uid.bluetooth
		"com.android.bluetooth": "BLUETOOTH",

		// android.uid.shell
		"com.android.shell": "SHELL",
	}

	// Known constant UIDs defined in frameworks/base/core/java/android/os/Process.java.
	// GIDs are excluded.
	knownUIDs = map[int32]string{
		0:    "ROOT",
		1000: "ANDROID_SYSTEM",
		1001: "PHONE",
		1002: "BLUETOOTH",
		1007: "LOG",
		1010: "WIFI",
		1013: "MEDIA",
		1016: "VPN",
		1019: "DRM",
		1027: "NFC",
		1037: "SHARED_RELRO",
		2000: "SHELL",
	}
)

type stepData struct {
	timeMsec      float32
	level         float32
	displayState  *bspb.BatteryStats_System_DisplayState_State
	powerSaveMode *bspb.BatteryStats_System_PowerSaveMode_Mode
	idleMode      *bspb.BatteryStats_System_IdleMode_Mode
}

// WakelockInfo is a data structure used to sort wakelocks by time or count.
type WakelockInfo struct {
	Name     string
	UID      int32
	Duration time.Duration
	Count    float32
}

// byTime sorts wakelock by the time held.
type byTime []*WakelockInfo

func (a byTime) Len() int      { return len(a) }
func (a byTime) Swap(i, j int) { a[i], a[j] = a[j], a[i] }

// sort by decreasing time order then increasing alphabetic order to break the tie.
func (a byTime) Less(i, j int) bool {
	if x, y := a[i].Duration, a[j].Duration; x != y {
		return x > y
	}
	return a[i].Name < a[j].Name
}

// byCount sorts wakelock by count.
type byCount []*WakelockInfo

func (a byCount) Len() int      { return len(a) }
func (a byCount) Swap(i, j int) { a[i], a[j] = a[j], a[i] }

// sort by decreasing time order then increasing alphabetic order to break the tie
func (a byCount) Less(i, j int) bool {
	if x, y := a[i].Count, a[j].Count; x != y {
		return x > y
	}
	return a[i].Name < a[j].Name
}

// SortByTime ranks a slice of wakelocks by duration.
func SortByTime(items []*WakelockInfo) {
	sort.Sort(byTime(items))
}

// SortByCount ranks a slice of wakelocks by count.
func SortByCount(items []*WakelockInfo) {
	sort.Sort(byCount(items))
}

// ParseBatteryStats parses the aggregated battery stats in checkin report
// according to frameworks/base/core/java/android/os/BatteryStats.java.
func ParseBatteryStats(pc checkinutil.Counter, cr *checkinutil.CheckinReport, pkgs []*usagepb.PackageInfo) (*bspb.BatteryStats, []string, []error) {
	// Support a single version and single aggregation type in a checkin report.
	var aggregationType bspb.BatteryStats_AggregationType
	var allAppComputedPowerMah float32
	var appWakelock, kernelWakelock []*WakelockInfo

	p := &bspb.BatteryStats{}
	p.System = &bspb.BatteryStats_System{}
	uids, reportVersion, warnings, errs := parsePackageManager(pc, cr.RawPackageManager, p.GetSystem(), pkgs)
	if len(errs) > 0 {
		return nil, warnings, errs
	}
	kernelWakelockMap := make(map[string]*bspb.BatteryStats_System_KernelWakelock)
	for _, r := range cr.RawBatteryStats {
		var uid int32
		var rawAggregationType, section string
		// The first element in r is '9', which used to be the report version but is now just there as a legacy field.
		remaining, err := ParseSlice(pc, "All", r[1:], &uid,
			&rawAggregationType, &section)
		if err != nil {
			errs = append(errs, fmt.Errorf("error parsing entire line: %v", err))
			continue
		}
		switch rawAggregationType {
		case sinceCharged:
			aggregationType = bspb.BatteryStats_SINCE_CHARGED
		case current:
			aggregationType = bspb.BatteryStats_CURRENT
		case unplugged:
			aggregationType = bspb.BatteryStats_SINCE_UNPLUGGED
		default:
			errs = append(errs, fmt.Errorf("unsupported aggregation type %s", rawAggregationType))
			return nil, warnings, errs
		}

		uid = packageutils.AppID(uid)
		if uid == 0 {
			// Some lines that are parsed will provide a uid of 0, even though 0 is not the
			// correct uid for the relevant package.
			// See if we can find an application to claim this.
			pkg, err := packageutils.GuessPackage(strings.Join(remaining, ","), "", pkgs)
			if err != nil {
				errs = append(errs, err)
			}
			// Many applications will match with android, but we should already have the android
			// UID in the map, so ignore if a package matches with android.
			if pkg.GetPkgName() != "" && pkg.GetPkgName() != "android" {
				uid = packageutils.AppID(pkg.GetUid())
			}
		}
		stats, ok := uids[uid]
		if !ok {
			// Unexpected UID. Some packages are uploaded with a uid of 0 and so won't be found
			// until we come across a case like this. Try to determine package from list.
			// Passing an empty uid here because if we reach this case, then the uploaded package
			// in the list has a uid of 0.
			pkg, err := packageutils.GuessPackage(strings.Join(remaining, ","), "", pkgs)
			if err != nil {
				errs = append(errs, err)
			}
			if pkg.GetPkgName() != "" && pkg.GetPkgName() != "android" {
				stats = &bspb.BatteryStats_App{
					Name: pkg.PkgName,
					Uid:  proto.Int32(uid),
					Child: []*bspb.BatteryStats_App_Child{
						{
							Name:        pkg.PkgName,
							VersionCode: pkg.VersionCode,
							VersionName: pkg.VersionName,
						},
					},
				}
				uids[uid] = stats
			} else {
				if _, ok := knownUIDs[uid]; !ok {
					// We've already gone through the entire package list, and it's not a UID
					// that we already know about, so log a warning.
					warnings = append(warnings, fmt.Sprintf("found unexpected uid for section, %s", section))
				}
				stats = &bspb.BatteryStats_App{Uid: proto.Int32(uid)}
				uids[uid] = stats
			}
		}
		system := p.GetSystem()
		// Parse csv lines according to
		// frameworks/base/core/java/android/os/BatteryStats.java.
		switch section {
		case apkData:
			warn, paaErrs := parseAppApk(pc, remaining, stats)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, paaErrs...); e {
				return nil, warnings, errs
			}
		case processData:
			p := &bspb.BatteryStats_App_Process{}
			warn, plErrs := parseLine(section, remaining, p)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, plErrs...); e {
				return nil, warnings, errs
			}
			stats.Process = append(stats.Process, p)
		case sensorData:
			s := &bspb.BatteryStats_App_Sensor{}
			warn, plErrs := parseLine(section, remaining, s)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, plErrs...); e {
				return nil, warnings, errs
			}
			stats.Sensor = append(stats.Sensor, s)
		case stateTimeData:
			warn, passErrs := ParseAppStateTime(remaining, stats)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, passErrs...); e {
				return nil, warnings, errs
			}
		case vibratorData:
			warn, pavErrs := ParseAppVibrator(remaining, stats)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, pavErrs...); e {
				return nil, warnings, errs
			}
		case foregroundData:
			f := &bspb.BatteryStats_App_Foreground{}
			warn, plErrs := parseLine(section, remaining, f)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, plErrs...); e {
				return nil, warnings, errs
			}
			stats.Foreground = f
		case jobData:
			j := &bspb.BatteryStats_App_ScheduledJob{}
			warn, plErrs := parseLine(section, remaining, j)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, plErrs...); e {
				return nil, warnings, errs
			}
			stats.ScheduledJob = append(stats.ScheduledJob, j)
		case userActivityData:
			if uid != 0 {
				if err := parseAppUserActivity(section, remaining, stats); err != nil {
					errs = append(errs, err)
					return nil, warnings, errs
				}
			}
		case wakelockData:
			warn, pawErrs := parseAppWakelock(uid, section, remaining, stats, &appWakelock)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, pawErrs...); e {
				return nil, warnings, errs
			}
		case syncData:
			warn, pasErrs := parseAppSync(uid, section, remaining, stats)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, pasErrs...); e {
				return nil, warnings, errs
			}
		case networkData:
			warn, panErrs := ParseAppNetwork(reportVersion, remaining, stats)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, panErrs...); e {
				return nil, warnings, errs
			}
		case wifiData:
			warn, pawErrs := ParseAppWifi(remaining, stats)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, pawErrs...); e {
				return nil, warnings, errs
			}
		case kernelWakelockData:
			warn, psklErrs := parseSystemKernelWakelock(section, remaining, kernelWakelockMap, &kernelWakelock)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, psklErrs...); e {
				return nil, warnings, errs
			}
		case wakeupReasonData:
			if err := parseSystemWakeupReason(pc, remaining, system); err != nil {
				errs = append(errs, err)
				return nil, warnings, errs
			}
		case batteryData:
			b := &bspb.BatteryStats_System_Battery{}
			warn, plErrs := parseLine(section, remaining, b)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, plErrs...); e {
				return nil, warnings, errs
			}
			system.Battery = b
		case batteryDischargeData:
			b := &bspb.BatteryStats_System_BatteryDischarge{}
			warn, plErrs := parseLine(section, remaining, b)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, plErrs...); e {
				return nil, warnings, errs
			}
			system.BatteryDischarge = b
		case batteryLevelData:
			l := &bspb.BatteryStats_System_BatteryLevel{}
			warn, plErrs := parseLine(section, remaining, l)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, plErrs...); e {
				return nil, warnings, errs
			}
			system.BatteryLevel = l
		case miscData:
			warn, psmErrs := ParseSystemMisc(pc, reportVersion, remaining, system)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, psmErrs...); e {
				return nil, warnings, errs
			}
		case GlobalBluetoothData:
			warn, errs := ParseGlobalBluetooth(remaining, p.System)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, err); e {
				return nil, warnings, errs
			}
		case globalNetworkData:
			g := &bspb.BatteryStats_System_GlobalNetwork{}
			warn, plErrs := parseLine(section, remaining, g)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, plErrs...); e {
				return nil, warnings, errs
			}
			system.GlobalNetwork = g
		case GlobalWifiData:
			warn, errs := ParseGlobalWifi(remaining, p.System)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, err); e {
				return nil, warnings, errs
			}
		case screenBrightnessData:
			if err := parseSystemScreenBrightness(section, remaining, system); err != nil {
				errs = append(errs, err)
				return nil, warnings, errs
			}
		case signalScanningTimeData:
			s := &bspb.BatteryStats_System_SignalScanningTime{}
			warn, plErrs := parseLine(section, remaining, s)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, plErrs...); e {
				return nil, warnings, errs
			}
			system.SignalScanningTime = s
		case signalStrengthTimeData, signalStrengthCountData, dataConnectionTimeData, dataConnectionCountData, wifiStateTimeData, wifiStateCountData, bluetoothStateTimeData, bluetoothStateCountData, wifiSupplStateTimeData, wifiSupplStateCountData, wifiSignalStrengthTimeData, wifiSignalStrengthCountData:
			if err := parseSystemTimeCountPair(section, remaining, system); err != nil {
				errs = append(errs, err)
				return nil, warnings, errs
			}
		case powerUseSummaryData:
			p := &bspb.BatteryStats_System_PowerUseSummary{}
			warn, plErrs := parseLine(section, remaining, p)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, plErrs...); e {
				return nil, warnings, errs
			}
			system.PowerUseSummary = p
		case powerUseItemData:
			warn, err := ParseAppSystemPowerUseItem(pc, remaining, stats, p.System, &allAppComputedPowerMah)
			if e, warnings, errs := saveWarningsAndErrors(warnings, warn, errs, err); e {
				return nil, warnings, errs
			}
		default:
			warnings = append(warnings, fmt.Sprintf("unknown data category %s", section))
		}
	}

	processAppInfo(uids)

	// Copy uids to p.App.
	for _, app := range uids {
		p.App = append(p.App, app)
	}
	// Copy to p.System.
	var kernelWakelockKeys []string
	for key := range kernelWakelockMap {
		kernelWakelockKeys = append(kernelWakelockKeys, key)
	}
	sort.Strings(kernelWakelockKeys)
	for _, key := range kernelWakelockKeys {
		p.System.KernelWakelock = append(p.System.KernelWakelock, kernelWakelockMap[key])
	}
	p.System.PowerUseItem = append(p.System.PowerUseItem,
		&bspb.BatteryStats_System_PowerUseItem{
			Name:             bspb.BatteryStats_System_PowerUseItem_APP.Enum(),
			ComputedPowerMah: proto.Float32(allAppComputedPowerMah),
		})
	if m := p.System.GetMisc(); m != nil {
		// Screen off time is calculated by subtracting screen on time from total battery real time.
		diff := p.System.GetBattery().GetBatteryRealtimeMsec() - m.GetScreenOnTimeMsec()
		m.ScreenOffTimeMsec = proto.Float32(diff)
		if diff < 0 {
			errs = append(errs, fmt.Errorf("negative screen off time"))
		}

		if reportVersion >= 14 {
			// These won't have been populated through regular parsing for version 14+ so it's safe to overwrite here.
			m.WifiOnTimeMsec = p.System.GlobalWifi.WifiOnTimeMsec
			m.WifiRunningTimeMsec = p.System.GlobalWifi.WifiRunningTimeMsec
			m.MobileBytesRx = p.System.GlobalNetwork.MobileBytesRx
			m.MobileBytesTx = p.System.GlobalNetwork.MobileBytesTx
			m.WifiBytesRx = p.System.GlobalNetwork.WifiBytesRx
			m.WifiBytesTx = p.System.GlobalNetwork.WifiBytesTx
		}

	}
	p.ReportVersion = proto.Int32(reportVersion)
	p.AggregationType = aggregationType.Enum()
	p.StartTimeUsec = proto.Int64(p.System.GetBattery().GetStartClockTimeMsec() * 1000)
	p.EndTimeUsec = proto.Int64(cr.TimeUsec)
	gmsPkg, err := packageutils.GuessPackage("com.google.android.gms", "", pkgs)
	if err != nil {
		errs = append(errs, err)
	}
	if gmsPkg != nil {
		p.GmsVersion = gmsPkg.VersionCode
	}

	p.Build = build.Build(cr.BuildID)
	if p.GetBuild().GetType() == "user" {
		for _, tag := range p.GetBuild().GetTags() {
			if tag == "release-keys" {
				p.IsUserRelease = proto.Bool(true)
				break
			}
		}
	}
	p.DeviceGroup = cr.DeviceGroup
	p.CheckinRule = cr.CheckinRule
	p.Radio = proto.String(cr.Radio)
	p.SdkVersion = proto.Int32(cr.SDKVersion)
	p.Bootloader = proto.String(cr.Bootloader)
	if cr.CellOperator != "" {
		p.Carrier = proto.String(cr.CellOperator + "/" + cr.CountryCode)
	}
	p.CountryCode = proto.String(cr.CountryCode)
	p.TimeZone = proto.String(cr.TimeZone)

	return p, warnings, errs
}

// CreateCheckinReport creates a checkinutil.CheckinReport from the given
// sessionpb.Checkin.
func CreateCheckinReport(cp *sessionpb.Checkin) *checkinutil.CheckinReport {
	pm, bs := extractCSV(cp.GetCheckin())
	return &checkinutil.CheckinReport{
		TimeUsec:          cp.GetBucketSnapshotMsec() * 1000,
		TimeZone:          cp.GetSystemInfo().GetTimeZone(),
		AndroidID:         cp.GetAndroidId(),
		DeviceGroup:       cp.Groups,
		BuildID:           cp.GetBuildFingerprint(),
		Radio:             cp.GetSystemInfo().GetBasebandRadio(),
		Bootloader:        cp.GetSystemInfo().GetBootloader(),
		SDKVersion:        cp.GetSystemInfo().GetSdkVersion(),
		CellOperator:      cp.GetSystemInfo().GetNetworkOperator(),
		CountryCode:       cp.GetSystemInfo().GetCountryCode(),
		RawBatteryStats:   bs,
		RawPackageManager: pm,
	}
}

// saveWarningsAndErrors appends new errors (ne) and new warnings (nw) to existing slices
// and returns true if new errors were added
func saveWarningsAndErrors(warnings []string, nw string, errors []error, ne ...error) (bool, []string, []error) {
	newErr := false
	for _, e := range ne {
		if e != nil {
			errors = append(errors, e)
			newErr = true
		}
	}
	if len(nw) > 0 {
		warnings = append(warnings, nw)
	}
	return newErr, warnings, errors
}

// updateWakelock adds a wakelock with the specified name into processed if
// the name does not match any wakelock in processed and initializes wakelock
// held time to time. If such wakelock already exists, we increment its held
// time by time.
func updateWakelock(processed []*WakelockInfo, name string, uid int32, d time.Duration) []*WakelockInfo {
	// processed contains a list of wakelocks we have seen.
	isAdded := false
	for _, w := range processed {
		if w.Name == name {
			w.Duration += d
			isAdded = true
			break
		}
	}
	if !isAdded {
		processed = append(processed, &WakelockInfo{
			Name:     name,
			UID:      uid,
			Duration: d,
		})
	}
	return processed
}

func extractCSV(input string) ([][]string, [][]string) {
	// pkgbs contains package information, separated by line and comma
	// bs contains since last charged stats, separated by line and comma
	var pkgbs, bs [][]string
	// we only use since charged data (ignore unplugged data)
	for _, line := range strings.Split(input, "\n") {
		line = strings.TrimSpace(line)
		arr := strings.Split(line, ",")
		if len(arr) < minNumFields {
			continue
		}
		switch arr[2] {
		case packageInfo:
			pkgbs = append(pkgbs, arr)
		case sinceCharged:
			bs = append(bs, arr)
		}
	}
	return pkgbs, bs
}

// parseStepData parses sliced lines that were orginally in the form 9,0,i,csd,65975,40,sd,p-
// Use this to parse lines for CHARGE_STEP_DATA (csd) and DISCHARGE_STEP_DATA (dsd).
func parseStepData(r []string) (*stepData, string, error) {
	var err error
	var warn string
	var tm, l float32
	var ds bspb.BatteryStats_System_DisplayState_State
	var psm bspb.BatteryStats_System_PowerSaveMode_Mode
	var im bspb.BatteryStats_System_IdleMode_Mode

	if len(r) > 4 {
		tm, err = ParseFloat32(r[4])
		if err != nil {
			return nil, warn, err
		}
	}

	if len(r) > 5 {
		// A ? indicates a bug/error with the display state in the log and so we should treat it as such.
		// The ? was intended for index 6, but was in index 5 due to a bug in BatteryStats.java (fixed in ag/666451).
		if r[5] == "?" {
			return nil, warn, errors.New("discovered ? for display state")
		}
		l, err = ParseFloat32(r[5])
		if err != nil {
			return nil, warn, err
		}
	}

	ds = bspb.BatteryStats_System_DisplayState_MIXED
	if len(r) > 6 {
		switch r[6] {
		case "s+":
			ds = bspb.BatteryStats_System_DisplayState_ON
		case "s-":
			ds = bspb.BatteryStats_System_DisplayState_OFF
		case "sd":
			ds = bspb.BatteryStats_System_DisplayState_DOZE
		case "sds":
			ds = bspb.BatteryStats_System_DisplayState_DOZE_SUSPEND
		case "": // Empty strings are valid.
			ds = bspb.BatteryStats_System_DisplayState_MIXED
		case "?": // A ? indicates a bug/error in the log and so we should treat it as such.
			return nil, warn, errors.New("discovered ? when parsing display state")
		default:
			warn = fmt.Sprintf("unknown display state: %s", r[6])
		}
	}

	psm = bspb.BatteryStats_System_PowerSaveMode_MIXED
	im = bspb.BatteryStats_System_IdleMode_NO_DATA
	if len(r) > 7 {
		switch r[7] {
		case "p+":
			psm = bspb.BatteryStats_System_PowerSaveMode_ON
		case "p-":
			psm = bspb.BatteryStats_System_PowerSaveMode_OFF
		case "": // Empty strings are valid.
			psm = bspb.BatteryStats_System_PowerSaveMode_MIXED
		// i+ and i- were in the 8th slot due to a bug in BatteryStats.java (fixed in ag/666451).
		case "i+":
			im = bspb.BatteryStats_System_IdleMode_ON
		case "i-":
			im = bspb.BatteryStats_System_IdleMode_OFF
		default:
			warn = fmt.Sprintf("unknown power save mode: %s", r[7])
		}
	}

	if len(r) > 8 {
		switch r[8] {
		case "i+":
			im = bspb.BatteryStats_System_IdleMode_ON
		case "i-":
			im = bspb.BatteryStats_System_IdleMode_OFF
		case "": // Empty strings are valid.
			im = bspb.BatteryStats_System_IdleMode_MIXED
		default:
			warn = fmt.Sprintf("unknown idle mode: %s", r[8])
		}
	}

	return &stepData{
		timeMsec:      tm,
		level:         l,
		displayState:  &ds,
		powerSaveMode: &psm,
		idleMode:      &im,
	}, warn, nil
}

// processAppInfo tries to determine the best name and version_code to assign
// to the BatteryStats_App element of each shared uid.
func processAppInfo(uids map[int32]*bspb.BatteryStats_App) []error {
	var errs []error

	for uid, app := range uids {
		known := false
		var headChild *bspb.BatteryStats_App_Child
		var childNames []string

		for _, child := range app.Child {
			childNames = append(childNames, child.GetName())

			// Check to see if it's any of the other shared UIDs.
			if val, ok := packageNameToSharedUIDMap[child.GetName()]; !known && ok {
				app.Name = proto.String(val)
				known = true
			} else if known && ok && app.GetName() != val {
				errs = append(errs, fmt.Errorf("package groups not matched properly"))
			}
		}

		app.Uid = proto.Int32(uid)
		if name, ok := knownUIDs[uid]; ok {
			app.Name = proto.String(name)
			if headChild == nil {
				continue
			}
		}

		if len(app.Child) == 1 && headChild == nil {
			headChild = app.GetChild()[0]
		}

		app.VersionCode = proto.Int32(headChild.GetVersionCode())
		app.HeadChild = headChild

		// The children aren't part of any known shared UIDs.
		// Creating a name based on the concatenation of children's names, as defined in ../batterystats/parse.go
		if !known {
			sort.Strings(childNames) // Needed for consistent ordering
			app.Name = proto.String(strings.Join(childNames, "/"))
		}
	}

	return errs
}

// parsePackageManager parses the uid, vers, dsd, csd, ctr, and dtr
// sections of the checkin report. It builds a map from uid to address
// of a BatteryStats_App proto. The proto contains a slice of packages
// that share the same uid the rest of the proto are filled in later.
// It also fills in information about the system into the
// BatteryStats_System proto.
func parsePackageManager(pc checkinutil.Counter, bs [][]string, ps *bspb.BatteryStats_System, pkgs []*usagepb.PackageInfo) (map[int32]*bspb.BatteryStats_App, int32, []string, []error) {
	// Use a map to ensure we don't double count packages.
	apps := make(map[string]*usagepb.PackageInfo)
	for _, p := range pkgs {
		apps[p.GetPkgName()] = p
	}

	uids := make(map[int32]*bspb.BatteryStats_App)
	var dsds []*bspb.BatteryStats_System_DischargeStep
	var csds []*bspb.BatteryStats_System_ChargeStep
	var reportVersion int32
	var errs []error
	var warns []string
	savedErr := false

	for _, r := range bs {
		// Expect inputs like "8,0,i,uid,1000,com.android.settings".
		switch r[3] {
		case uidData:
			var uid int32
			var name string
			if _, err := ParseSlice(pc, r[3], r[4:], &uid, &name); err != nil {
				errs = append(errs, fmt.Errorf("error parsing PackageManager: %v", err))
				continue
			}
			uid = packageutils.AppID(uid)
			if _, known := apps[name]; !known {
				apps[name] = &usagepb.PackageInfo{
					PkgName: proto.String(name),
					Uid:     proto.Int32(uid),
				}
			} else if packageutils.AppID(apps[name].GetUid()) == 0 {
				// It looks like a lot of packages have a uid of 0 coming from the device.
				// TODO: figure out why we're getting UIDs of 0 on the device side.
				apps[name].Uid = proto.Int32(uid)
			}
		// Expected format: 9,0,i,dsd,28124,21,s+,p-
		case dischargeStepData:
			data, warn, err := parseStepData(r)
			if savedErr, warns, errs = saveWarningsAndErrors(warns, warn, errs, err); savedErr {
				continue
			}

			step := &bspb.BatteryStats_System_DischargeStep{
				TimeMsec:      proto.Float32(data.timeMsec),
				Level:         proto.Float32(data.level),
				DisplayState:  data.displayState,
				PowerSaveMode: data.powerSaveMode,
				IdleMode:      data.idleMode,
			}
			dsds = append(dsds, step)
		// Expected format: 9,0,i,csd,28124,21,s+,p-
		case chargeStepData:
			data, warn, err := parseStepData(r)
			if savedErr, warns, errs = saveWarningsAndErrors(warns, warn, errs, err); savedErr {
				continue
			}

			step := &bspb.BatteryStats_System_ChargeStep{
				TimeMsec:      proto.Float32(data.timeMsec),
				Level:         proto.Float32(data.level),
				DisplayState:  data.displayState,
				PowerSaveMode: data.powerSaveMode,
				IdleMode:      data.idleMode,
			}
			csds = append(csds, step)
		// 9,0,i,vers,11,114,LRX21O,LRX21O
		case versionData:
			if len(r) < 6 {
				errs = append(errs, errors.New("vers section does not contain enough fields"))
				continue
			}
			if _, err := ParseSlice(pc, versionData, r[4:5], &reportVersion); err != nil {
				errs = append(errs, fmt.Errorf("error parsing PackageManager: %v", err))
				continue
			}
			if reportVersion < minParseReportVersion {
				errs = append(errs, fmt.Errorf("old report version %d", reportVersion))
				continue
			} else if reportVersion > maxParseReportVersion {
				warns = append(warns, fmt.Sprintf("newer report version %d found", reportVersion))
			}
		// Current format: 9,0,i,dtr,18147528000
		case dischargeTimeRemainData:
			// Case put here to acknowledge that we know about the section, but the information currently included is not useful for analysis.
			if len(r) > 5 {
				warns = append(warns, fmt.Sprintf("%s now has additional data", r[3]))
			}
		// Current format: 9,0,i,ctr,18147528000
		case chargeTimeRemainData:
			// Case put here to acknowledge that we know about the section, but the information currently included is not useful for analysis.
			if len(r) > 5 {
				warns = append(warns, fmt.Sprintf("%s now has additional data", r[3]))
			}
		default:
			warns = append(warns, fmt.Sprintf("unknown package manager section %s", r[3]))
		}
	}

	// We've gone through both sources of package/uid info; now we can create the App and Child elements.
	for _, p := range apps {
		uid := packageutils.AppID(p.GetUid())
		if uid == 0 {
			// Skip packages uploaded with a UID of 0 (this would be the case for old builds).
			continue
		}
		stats := uids[uid]
		if stats == nil {
			stats = &bspb.BatteryStats_App{
				Uid: proto.Int32(uid),
			}
			uids[uid] = stats
		}
		stats.Child = append(stats.Child,
			&bspb.BatteryStats_App_Child{
				Name:        p.PkgName,
				VersionCode: p.VersionCode,
				VersionName: p.VersionName,
			})
	}

	// New discharge step info is added to the top of the list thus we
	// need to traverse in the reverse order to read from the start
	for i := len(dsds) - 1; i >= 0; i-- {
		ps.DischargeStep = append(ps.DischargeStep, dsds[i])
	}

	// similar to dsd, traverse in the reverse order
	for i := len(csds) - 1; i >= 0; i-- {
		ps.ChargeStep = append(ps.ChargeStep, csds[i])
	}

	return uids, reportVersion, warns, errs
}

// parseAppApk parses "apk"(APK_DATA) in App.
// format: 8,1000,l,apk,5719,android,android.hardware.location.GeofenceHardwareService,0,0,2
// wakeup alarms, Apk name, service name, time spent started, start count, launch count
func parseAppApk(pc checkinutil.Counter, record []string, app *bspb.BatteryStats_App) (string, []error) {
	var name string
	var wakeups float32
	// "wakeups" and "name" are shared across services of the same app apk.
	record, err := ParseSlice(pc, apkData, record, &wakeups, &name)
	if err != nil {
		return "", []error{err}
	}
	isChild := false
	// pkg name should have been added when parsing package manager("uid").
	for _, child := range app.GetChild() {
		if child.GetName() == name {
			isChild = true
			break
		}
	}
	if !isChild {
		app.Child = append(app.Child, &bspb.BatteryStats_App_Child{Name: proto.String(name)})
	}
	if app.Apk == nil { // We need to process "wakeups" just once.
		app.Apk = &bspb.BatteryStats_App_Apk{Wakeups: proto.Float32(wakeups)}
	}
	s := &bspb.BatteryStats_App_Apk_Service{}
	warn, plErrs := parseLine(apkData, record, s)
	if len(plErrs) > 0 {
		return warn, plErrs
	}
	app.Apk.Service = append(app.Apk.Service, s)
	return warn, nil
}

// parseAppUserActivity parses "au"(USER_ACTIVITY_TYPES) in App.
// format: 8,1000,l,ua,2,0,0
// "other", "button", "touch" activity counts
func parseAppUserActivity(section string, record []string, app *bspb.BatteryStats_App) error {
	for name, rawCount := range record {
		Count, err := ParseFloat32(rawCount)
		if err != nil {
			return err
		}
		app.UserActivity = append(app.UserActivity,
			&bspb.BatteryStats_App_UserActivity{
				Name:  bspb.BatteryStats_App_UserActivity_Name(name).Enum(),
				Count: proto.Float32(Count),
			})
	}
	return nil
}

// ParseAppSystemPowerUseItem parses "pwi"(POWER_USE_ITEM_DATA) in App and System's PowerUseItem.
// We need to match raw item name with proto item name, so we parse manually.
// format: 8,0,u,pwi,unacc,2277
// drain type, power in mAh
// If drain type is "uid", it's per-app data, we add power in mAh into its app proto
// If drain type matches other types specified in "powerUseItemNameMap", we add
// it to system proto.
// If app has a PowerUseItem already, then newly found values from parsing will be added to it.
// The most common case of this would be when an app is installed on a device with multiple users
// (ie. with a work profile). In such cases, the app uid is combined with the user ID (to create
// UIDs such as 1010011 vs 10011) and thus the app is treated and reported separately for each profile.
// TODO: we currently combine them all under the same UID. In the future, we should separate them.
// The sum of app consumed power will be added to system proto later.
func ParseAppSystemPowerUseItem(pc checkinutil.Counter, record []string, app *bspb.BatteryStats_App, system *bspb.BatteryStats_System, allAppComputedPowerMah *float32) (string, error) {
	var rawName string
	var computedPowerMah float32
	if _, err := ParseSlice(pc, powerUseItemData, record, &rawName, &computedPowerMah); err != nil {
		return "", err
	}
	if rawName == "uid" {
		*allAppComputedPowerMah += computedPowerMah
		pb := app.GetPowerUseItem()
		if pb == nil {
			pb = &bspb.BatteryStats_App_PowerUseItem{}
			app.PowerUseItem = pb
		}
		pb.ComputedPowerMah = proto.Float32(pb.GetComputedPowerMah() + computedPowerMah)
	} else if name, ok := powerUseItemNameMap[rawName]; ok {
		system.PowerUseItem = append(system.PowerUseItem,
			&bspb.BatteryStats_System_PowerUseItem{
				Name:             name.Enum(),
				ComputedPowerMah: proto.Float32(computedPowerMah),
			})
	} else {
		pc.Count("unknown-app-system-power-use-item-"+rawName, 1)
		return fmt.Sprintf("Unknown powerUseItem name %s", rawName), nil
	}
	return "", nil
}

// ParseAppStateTime parses record into app's StateTime.
//
// record holds content from BatteryStats's stateTimeSection.
//    e.g., 19447364,19447364,19447364
// If app has a StateTime already, then newly found values from parsing will be added to it.
func ParseAppStateTime(record []string, app *bspb.BatteryStats_App) (string, []error) {
	s := &bspb.BatteryStats_App_StateTime{}
	warn, errs := parseLine(stateTimeData, record, s)
	if len(errs) > 0 {
		return warn, errs
	}

	pb := app.GetStateTime()
	if pb == nil {
		app.StateTime = s
		return warn, nil
	}
	pb.ForegroundTimeMsec = proto.Float32(pb.GetForegroundTimeMsec() + s.GetForegroundTimeMsec())
	pb.ActiveTimeMsec = proto.Float32(pb.GetActiveTimeMsec() + s.GetActiveTimeMsec())
	pb.RunningTimeMsec = proto.Float32(pb.GetRunningTimeMsec() + s.GetRunningTimeMsec())
	return warn, nil
}

// parseAppSync parses "sy"(SYNC_DATA) in App.
// format: 8,10007,l,sy,com.google.android.gms.games/com.google/...@gmail.com,2161,4
// name, total time locked, count
func parseAppSync(uid int32, section string, record []string, app *bspb.BatteryStats_App) (string, []error) {
	isAdded := false
	s := &bspb.BatteryStats_App_Sync{}
	warn, plErrs := parseLine(section, record, s)
	if len(plErrs) > 0 {
		return warn, plErrs
	}
	// Scrub PII from the sync name
	s.Name = proto.String(s.GetName())
	for _, s1 := range app.Sync {
		if s1.GetName() == s.GetName() {
			*s.TotalTimeMsec += s1.GetTotalTimeMsec()
			*s.Count += s1.GetCount()
			isAdded = true
			break
		}
	}
	if !isAdded {
		app.Sync = append(app.Sync, s)
	}
	return warn, nil
}

// ParseAppVibrator parses record into app's Vibrator.
//
// record holds content from BatteryStats's vibratorSection.
//   e.g., 14,2
// If app has a Vibrator field already, then newly found values from parsing will be added to it.
func ParseAppVibrator(record []string, app *bspb.BatteryStats_App) (string, []error) {
	v := &bspb.BatteryStats_App_Vibrator{}
	warn, plErrs := parseLine(vibratorData, record, v)
	if len(plErrs) > 0 {
		return warn, plErrs
	}
	pb := app.GetVibrator()
	if pb == nil {
		app.Vibrator = v
		return warn, nil
	}
	pb.TotalTimeMsec = proto.Float32(pb.GetTotalTimeMsec() + v.GetTotalTimeMsec())
	pb.Count = proto.Float32(pb.GetCount() + v.GetCount())
	return warn, nil
}

// parseAppWakelock parses "wl"(WAKELOCK_DATA) in App.
// format: 8,1000,l,wl,ConnectivityService,0,f,0,15411273,p,263,0,w,0
// name, full wakelock time,    "f"(for full),    full wakelock count,
//       partial wakelock time, "p"(for partial), partial wakelock count
//       window wakelock time,  "w"(for window),  window wakelock count
func parseAppWakelock(uid int32, section string, record []string, app *bspb.BatteryStats_App, appWakelock *[]*WakelockInfo) (string, []error) {
	w := &bspb.BatteryStats_App_Wakelock{}
	isAdded := false
	// The line contains letters that represent wakelock types, we skip those fields.
	warn, plErrs := parseLineWithSkip(section, record, w, []int{2 /*"f"*/, 5 /*"p"*/, 8 /*"w"*/})
	if len(plErrs) > 0 {
		return warn, plErrs
	}
	for _, w1 := range app.Wakelock {
		if w1.GetName() == w.GetName() {
			*w.FullTimeMsec += w.GetFullTimeMsec()
			*w.FullCount += w.GetFullCount()
			*w.PartialTimeMsec += w.GetPartialTimeMsec()
			*w.PartialCount += w.GetPartialCount()
			*w.WindowTimeMsec += w.GetWindowTimeMsec()
			*w.WindowCount += w.GetWindowCount()
			isAdded = true
			break
		}
	}
	if !isAdded {
		app.Wakelock = append(app.Wakelock, w)
	}
	*appWakelock = updateWakelock(
		*appWakelock,
		w.GetName(),
		uid,
		time.Duration(w.GetFullTimeMsec()+w.GetPartialTimeMsec()+w.GetWindowTimeMsec())*time.Millisecond)
	return warn, nil
}

// ParseAppNetwork parses "nt" (NETWORK_DATA) into App.
//
// record holds content from BatteryStats's networkData.
//   e.g., 0,0,996,1389 (reportVersion < 8)
//   e.g., 0,0,8987,7051,0,0,25,29,0,0 (reportVersion >= 8)
// If app has a Network field already, then newly found values from parsing will be added to it.
// The most common case of this would be when an app is installed on a device with multiple users
// (ie. with a work profile). In such cases, the app uid is combined with the user ID (to create
// UIDs such as 1010011 vs 10011) and thus the app is treated and reported separately for each profile.
func ParseAppNetwork(reportVersion int32, record []string, app *bspb.BatteryStats_App) (string, []error) {
	n := &bspb.BatteryStats_App_Network{}
	warn, errs := parseLine(networkData, record, n)
	if len(errs) > 0 {
		return warn, errs
	}
	// MobileActiveTime is output in microseconds in the log, so we convert to milliseconds here.
	n.MobileActiveTimeMsec = proto.Float32(n.GetMobileActiveTimeMsec() / 1e3)

	pb := app.GetNetwork()
	if pb == nil {
		app.Network = n
		return warn, nil
	}

	pb.MobileBytesRx = proto.Float32(pb.GetMobileBytesRx() + n.GetMobileBytesRx())
	pb.MobileBytesTx = proto.Float32(pb.GetMobileBytesTx() + n.GetMobileBytesTx())
	pb.WifiBytesRx = proto.Float32(pb.GetWifiBytesRx() + n.GetWifiBytesRx())
	pb.WifiBytesTx = proto.Float32(pb.GetWifiBytesTx() + n.GetWifiBytesTx())
	pb.MobilePacketsRx = proto.Float32(pb.GetMobilePacketsRx() + n.GetMobilePacketsRx())
	pb.MobilePacketsTx = proto.Float32(pb.GetMobilePacketsTx() + n.GetMobilePacketsTx())
	pb.WifiPacketsRx = proto.Float32(pb.GetWifiPacketsRx() + n.GetWifiPacketsRx())
	pb.WifiPacketsTx = proto.Float32(pb.GetWifiPacketsTx() + n.GetWifiPacketsTx())
	pb.MobileActiveTimeMsec = proto.Float32(pb.GetMobileActiveTimeMsec() + n.GetMobileActiveTimeMsec())
	pb.MobileActiveCount = proto.Float32(pb.GetMobileActiveCount() + n.GetMobileActiveCount())

	return warn, nil
}

// ParseAppWifi parses "wfl"(WIFI_DATA) in App.
// Parse manually due to unit conversion. If app has a Wifi field already,
// then newly found values from parsing will be added to it.
// format: 14,10009,l,wfl,1386709324,304313000,0,3000,1500,500
// full wifi lock on time (usec), wifi scan time (usec), app wifi running time (usec), wifi idle time (msec), wifi Rx time (msec), wifi Tx time (msec)
func ParseAppWifi(record []string, app *bspb.BatteryStats_App) (string, []error) {
	if len(record) < 3 {
		return "", []error{fmt.Errorf("%s line didn't contain enough fields", wifiData)}
	}

	w := &bspb.BatteryStats_App_Wifi{}
	warn, errs := parseLine(wifiData, record, w)
	if len(errs) > 0 {
		return warn, errs
	}

	// fullWifiLockTime, scanTime, runningTime are reported in usec, not msec, we convert them to msec here
	w.FullWifiLockTimeMsec = proto.Float32(w.GetFullWifiLockTimeMsec() / 1e3)
	w.ScanTimeMsec = proto.Float32(w.GetScanTimeMsec() / 1e3)
	w.RunningTimeMsec = proto.Float32(w.GetRunningTimeMsec() / 1e3)

	pb := app.GetWifi()
	if pb == nil {
		app.Wifi = w
		return warn, nil
	}

	pb.FullWifiLockTimeMsec = proto.Float32(pb.GetFullWifiLockTimeMsec() + w.GetFullWifiLockTimeMsec())
	pb.ScanTimeMsec = proto.Float32(pb.GetScanTimeMsec() + w.GetScanTimeMsec())
	pb.RunningTimeMsec = proto.Float32(pb.GetRunningTimeMsec() + w.GetRunningTimeMsec())
	pb.ScanCount = proto.Float32(pb.GetScanCount() + w.GetScanCount())
	pb.IdleTimeMsec = proto.Float32(pb.GetIdleTimeMsec() + w.GetIdleTimeMsec())
	pb.RxTimeMsec = proto.Float32(pb.GetRxTimeMsec() + w.GetRxTimeMsec())
	pb.TxTimeMsec = proto.Float32(pb.GetTxTimeMsec() + w.GetTxTimeMsec())
	return warn, nil
}

// parseSystemKernelWaeklock parses "kwl"(KERNEL_WAKELOCK_DATA) in system
// format: 8,0,l,kwl,ipc000000b0_sensors.qcom,0,0
// wakelock name, time, count
func parseSystemKernelWakelock(section string, record []string, kernelWakelockMap map[string]*bspb.BatteryStats_System_KernelWakelock, kernelWakelock *[]*WakelockInfo) (string, []error) {
	w := &bspb.BatteryStats_System_KernelWakelock{}
	warn, plErrs := parseLine(section, record, w)
	if len(plErrs) > 0 {
		return warn, plErrs
	}
	if kernelWakelock, ok := kernelWakelockMap[w.GetName()]; ok {
		kernelWakelock.TimeMsec = proto.Float32(kernelWakelock.GetTimeMsec() + w.GetTimeMsec())
		kernelWakelock.Count = proto.Float32(kernelWakelock.GetCount() + w.GetCount())
	} else {
		kernelWakelockMap[w.GetName()] = w
	}
	*kernelWakelock = updateWakelock(*kernelWakelock, w.GetName(), 0 /* uid */, time.Duration(w.GetTimeMsec())*time.Millisecond)
	return warn, nil
}

// ParseSystemMisc parses "m"(MISC_DATA) in System.
// format:
// 9,0,l,m,12469,0,20657343842,0,0,0,11258,0,0,5000,2,3000,1 (reportVersion >= 14)
// 9,0,l,m,12469,0,228195853,228195672,0,0,0,8889296,3246978,0,20657343842,0,0,0,11258,0,0 (8 <= reportVersion < 14)
// 8,0,l,m,47452,0,19133321,19133231,0,0,0,1863222,1605056,0,918161,0 (reportVersion < 8)
//
// screen on time, phone on time, [wifi on time, wifi running time,
// bluetooth on time, mobile rx total bytes, mobile tx total bytes,
// wifi rx total bytes, wifi tx total bytes, legacy input event count(always 0)]
// mobile radio active time, mobile radio active adjusted time
// low power mode enabled time, [# connectivity changes],
// [device idle mode enabled time, device idle mode enabled count,
// device idling time, device idling count]
func ParseSystemMisc(pc checkinutil.Counter, reportVersion int32, record []string, system *bspb.BatteryStats_System) (string, []error) {
	if system.GetMisc() != nil {
		pc.Count("error-parse-system-misc-exist", 1)
		return "", []error{errors.New("misc field already exists")}
	}

	m := &bspb.BatteryStats_System_Misc{}
	// screen off time is not part of the line(calculated by subtracting screen
	// on time from battery real time. We put a dummy value in the input slice,
	// so we can still parse the other fields in the format specified by proto.
	record = append(record[:1], append([]string{"0"}, record[1:]...)...)

	var warn string
	var errs []error
	if reportVersion >= 14 {
		// Legacy data was removed from the line in version 14 (ag/674773). Adding
		// dummy values so we can continue using predefined functions.
		record = append(record[:3], append([]string{"0", "0", "0", "0", "0", "0", "0"}, record[3:]...)...)
		warn, errs = parseLine(miscData, record, m)
	} else {
		warn, errs = parseLineWithSkip(miscData, record, m, []int{12} /* legacy input */)
	}

	if len(errs) == 0 {
		if reportVersion < 9 { // due to change in android client side (ag/500625)
			m.FullWakelockTimeMsec = proto.Float32(m.GetFullWakelockTimeMsec() / 1e3)
			m.PartialWakelockTimeMsec = proto.Float32(m.GetPartialWakelockTimeMsec() / 1e3)
			m.MobileActiveTimeMsec = proto.Float32(m.GetMobileActiveTimeMsec() / 1e3)
			m.MobileActiveAdjustedTimeMsec = proto.Float32(m.GetMobileActiveAdjustedTimeMsec() / 1e3)
		}

		system.Misc = m
	}
	return warn, errs
}

// ParseGlobalBluetooth parses "gble" (GLOBAL_BLUETOOTH_DATA") into system.
// format: 9,0,l,gble,15,16,17,18
// bluetooth_idle_time_msec, bluetooth_rx_time_msec, bluetooth_tx_time_msec, bluetooth_power_mah
func ParseGlobalBluetooth(record []string, system *bspb.BatteryStats_System) (string, []error) {
	g := &bspb.BatteryStats_System_GlobalBluetooth{}
	warn, errs := parseLine(GlobalBluetoothData, record, g)
	if len(errs) == 0 {
		system.GlobalBluetooth = g
	}
	return warn, errs
}

// ParseGlobalWifi parses "gwfl" (GLOBAL_WIFI_DATA") into system.
// format: 9,0,l,gwfl,9,10,11,12,13,14
// wifi_on_time_msec, wifi_running_time_msec, wifi_idle_time_msec, wifi_rx_time_msec, wifi_tx_time_msec, wifi_power_mah
func ParseGlobalWifi(record []string, system *bspb.BatteryStats_System) (string, []error) {
	g := &bspb.BatteryStats_System_GlobalWifi{}
	warn, errs := parseLine(GlobalWifiData, record, g)
	if len(errs) == 0 {
		system.GlobalWifi = g
	}
	return warn, errs
}

// parseSystemScreenBrightness parses "br"(SCREEN_BRIGHTNESS_DATA) in System.
// format: 8,0,l,br,0,0,56369,0,0
// time spent from level 0 to 4
// (0: DARK, ..., 4:BRIGHT, see proto for details)
func parseSystemScreenBrightness(section string, record []string, system *bspb.BatteryStats_System) error {
	for name, rawTimeMsec := range record {
		timeMsec, err := ParseFloat32(rawTimeMsec)
		if err != nil {
			return err
		}
		system.ScreenBrightness = append(system.ScreenBrightness,
			&bspb.BatteryStats_System_ScreenBrightness{
				Name:     bspb.BatteryStats_System_ScreenBrightness_Name(name).Enum(),
				TimeMsec: proto.Float32(timeMsec),
			})
	}
	return nil
}

// parseSystemTimeCountPair parses categories that have time count pairs.
// format: time ends with "t", count ends with "c"
// each has five values corresponds to five levels
// (0: NONE OR UNKNOW, ..., 4: GREAT, see proto for details)
// 8,0,l,sgt,2307235,8838772,22120797,18900758,0
// 8,0,l,sgc,19,60,85,38,1
func parseSystemTimeCountPair(section string, record []string, system *bspb.BatteryStats_System) error {
	var initLen int
	if section == signalStrengthTimeData || section == signalStrengthCountData {
		initLen = len(system.SignalStrength)
	} else if section == dataConnectionTimeData || section == dataConnectionCountData {
		initLen = len(system.DataConnection)
	} else if section == wifiStateTimeData || section == wifiStateCountData {
		initLen = len(system.WifiState)
	} else if section == bluetoothStateTimeData || section == bluetoothStateCountData {
		initLen = len(system.BluetoothState)
	} else if section == wifiSupplStateTimeData || section == wifiSupplStateCountData {
		initLen = len(system.WifiSupplicantState)
	} else if section == wifiSignalStrengthTimeData || section == wifiSignalStrengthCountData {
		initLen = len(system.WifiSignalStrength)
	} else {
		return fmt.Errorf("parseSystemTimeCountPair encountered unknown section: %s", section)
	}

	if initLen == 0 { // No proto exists. Create a new proto and fill the field.
		for name, rawValue := range record {
			value, err := ParseFloat32(rawValue)
			if err != nil {
				return err
			}
			switch section {
			case signalStrengthTimeData:
				system.SignalStrength = append(system.SignalStrength,
					&bspb.BatteryStats_System_SignalStrength{
						Name:     bspb.BatteryStats_System_SignalStrength_Name(name).Enum(),
						TimeMsec: proto.Float32(value),
					})
			case signalStrengthCountData:
				system.SignalStrength = append(system.SignalStrength,
					&bspb.BatteryStats_System_SignalStrength{
						Name:  bspb.BatteryStats_System_SignalStrength_Name(name).Enum(),
						Count: proto.Float32(value),
					})
			case dataConnectionTimeData:
				system.DataConnection = append(system.DataConnection,
					&bspb.BatteryStats_System_DataConnection{
						Name:     bspb.BatteryStats_System_DataConnection_Name(name).Enum(),
						TimeMsec: proto.Float32(value),
					})
			case dataConnectionCountData:
				system.DataConnection = append(system.DataConnection,
					&bspb.BatteryStats_System_DataConnection{
						Name:  bspb.BatteryStats_System_DataConnection_Name(name).Enum(),
						Count: proto.Float32(value),
					})
			case wifiStateTimeData:
				system.WifiState = append(system.WifiState,
					&bspb.BatteryStats_System_WifiState{
						Name:     bspb.BatteryStats_System_WifiState_Name(name).Enum(),
						TimeMsec: proto.Float32(value),
					})
			case wifiStateCountData:
				system.WifiState = append(system.WifiState,
					&bspb.BatteryStats_System_WifiState{
						Name:  bspb.BatteryStats_System_WifiState_Name(name).Enum(),
						Count: proto.Float32(value),
					})
			case bluetoothStateTimeData:
				system.BluetoothState = append(system.BluetoothState,
					&bspb.BatteryStats_System_BluetoothState{
						Name:     bspb.BatteryStats_System_BluetoothState_Name(name).Enum(),
						TimeMsec: proto.Float32(value),
					})
			case bluetoothStateCountData:
				system.BluetoothState = append(system.BluetoothState,
					&bspb.BatteryStats_System_BluetoothState{
						Name:  bspb.BatteryStats_System_BluetoothState_Name(name).Enum(),
						Count: proto.Float32(value),
					})
			case wifiSignalStrengthTimeData:
				system.WifiSignalStrength = append(system.WifiSignalStrength, &bspb.BatteryStats_System_WifiSignalStrength{
					Name:     bspb.BatteryStats_System_WifiSignalStrength_Name(name).Enum(),
					TimeMsec: proto.Float32(value),
				})
			case wifiSignalStrengthCountData:
				system.WifiSignalStrength = append(system.WifiSignalStrength, &bspb.BatteryStats_System_WifiSignalStrength{
					Name:  bspb.BatteryStats_System_WifiSignalStrength_Name(name).Enum(),
					Count: proto.Float32(value),
				})
			case wifiSupplStateTimeData:
				system.WifiSupplicantState = append(system.WifiSupplicantState, &bspb.BatteryStats_System_WifiSupplicantState{
					Name:     bspb.BatteryStats_System_WifiSupplicantState_Name(name).Enum(),
					TimeMsec: proto.Float32(value),
				})
			case wifiSupplStateCountData:
				system.WifiSupplicantState = append(system.WifiSupplicantState, &bspb.BatteryStats_System_WifiSupplicantState{
					Name:  bspb.BatteryStats_System_WifiSupplicantState_Name(name).Enum(),
					Count: proto.Float32(value),
				})
			default:
				return fmt.Errorf("parseSystemTimeCountPair encountered unknown section: %s", section)
			}
		}
	} else if initLen == len(record) { // The proto exists. Just fill the field.
		for name, rawValue := range record {
			value, err := ParseFloat32(rawValue)
			if err != nil {
				return err
			}
			switch section {
			case signalStrengthTimeData:
				system.SignalStrength[name].TimeMsec = proto.Float32(value)
			case signalStrengthCountData:
				system.SignalStrength[name].Count = proto.Float32(value)
			case dataConnectionTimeData:
				system.DataConnection[name].TimeMsec = proto.Float32(value)
			case dataConnectionCountData:
				system.DataConnection[name].Count = proto.Float32(value)
			case wifiStateTimeData:
				system.WifiState[name].TimeMsec = proto.Float32(value)
			case wifiStateCountData:
				system.WifiState[name].Count = proto.Float32(value)
			case bluetoothStateTimeData:
				system.BluetoothState[name].TimeMsec = proto.Float32(value)
			case bluetoothStateCountData:
				system.BluetoothState[name].Count = proto.Float32(value)
			case wifiSupplStateTimeData:
				system.WifiSupplicantState[name].TimeMsec = proto.Float32(value)
			case wifiSupplStateCountData:
				system.WifiSupplicantState[name].Count = proto.Float32(value)
			case wifiSignalStrengthTimeData:
				system.WifiSignalStrength[name].TimeMsec = proto.Float32(value)
			case wifiSignalStrengthCountData:
				system.WifiSignalStrength[name].Count = proto.Float32(value)
			default:
				return fmt.Errorf("parseSystemTimeCountPair encountered unknown section: %s", section)
			}
		}
	} else {
		return fmt.Errorf("inconsistent number of fields in %s", section)
	}
	return nil
}

// parseSystemWakeupReason parses "wr"(WAKEUP_REASON_DATA) in System.
func parseSystemWakeupReason(pc checkinutil.Counter, record []string, system *bspb.BatteryStats_System) error {
	// This time is the amount of time we saw the CPU awake from when we received
	// a wake reason until we had another reason for it to be awake (someone
	// acquiring a user space wake lock or another sleep/wake happening).
	// 8,0,l,wr,"200:qcom,smd-rpm:222:fc4cf000.qcom,spmi",760
	name := strings.Join(record[:len(record)-1], ",")
	var timeMsec float32
	if _, err := ParseSlice(pc, wakeupReasonData, record[len(record)-1:], &timeMsec); err != nil {
		return err
	}
	system.WakeupReason = append(system.WakeupReason,
		&bspb.BatteryStats_System_WakeupReason{
			Name:     proto.String(name),
			TimeMsec: proto.Float32(timeMsec),
		})
	return nil
}

// ParseSlice wraps sliceparse.Consume(value, outputs...), increasing pc if it returns an error.
func ParseSlice(pc checkinutil.Counter, name string, value []string, outputs ...interface{}) ([]string, error) {
	remaining, err := sliceparse.Consume(value, outputs...)
	if err != nil {
		pc.Count("error-parse-slice-"+name, 1)
	}
	return remaining, err
}

// ParseFloat32 parses an individual 32-bit float.
func ParseFloat32(s string) (float32, error) {
	f64, err := strconv.ParseFloat(s, 32)
	return float32(f64), err
}

func parseValue(src string, dstV reflect.Value) error {
	var err error
	srcSlice := []string{src}
	switch dstV.Kind() {
	case reflect.Float32:
		var val float32
		_, err = sliceparse.Consume(srcSlice, &val)
		dstV.Set(reflect.ValueOf(val))
	case reflect.Float64:
		var val float64
		_, err = sliceparse.Consume(srcSlice, &val)
		dstV.Set(reflect.ValueOf(val))
	case reflect.Int32:
		var val int32
		_, err = sliceparse.Consume(srcSlice, &val)
		dstV.Set(reflect.ValueOf(val))
	case reflect.Int64:
		var val int64
		_, err = sliceparse.Consume(srcSlice, &val)
		dstV.Set(reflect.ValueOf(val))
	case reflect.String:
		dstV.Set(reflect.ValueOf(src))
	default:
		return fmt.Errorf("parse error: type %s not supported", dstV.Kind().String())
	}
	return err
}

// parseLineWithSkip skips string with specified index in record then uses parseLine
// to parse the remaining strings.
func parseLineWithSkip(section string, record []string, p proto.Message, skip []int) (string, []error) {
	sort.Ints(skip)
	next, nextSkip := 0, 0 // use next to traverse record, nextSkip to traverse skip.
	for i, s := range record {
		if nextSkip != -1 && i == skip[nextSkip] {
			nextSkip++
			if nextSkip == len(skip) {
				// stop skipping
				nextSkip = -1
			}
		} else {
			record[next] = s
			next++
		}
	}
	// Only need to pass the elements that were not skipped.
	return parseLine(section, record[:next], p)
}

// parseLine is a generic parsing function that parses a string slice into a proto.
// The proto should only have fields of type float32, float64, int32, int64 or string.
// The function determines the type a string should be parsed into by the type
// and order specified in the proto.
func parseLine(section string, record []string, p proto.Message) (string, []error) {
	var warn string
	var errs []error
	pV := reflect.ValueOf(p)
	// Because of backwards compatibility, there will be times when the proto
	// will have more fields than record can provide, so just fill up as many
	// fields as possible.
	num := len(record)
	if len(record) > pV.Elem().NumField()-1 {
		num = pV.Elem().NumField() - 1
		warn = fmt.Sprintf("The underlying format for %s has %d additional field(s) that are not captured.", section, len(record)-num)
	}

	for i := 0; i < num; i++ {
		valPtrV := reflect.New(pV.Elem().Field(i).Type().Elem())
		if err := parseValue(record[i], valPtrV.Elem()); err == nil {
			pV.Elem().Field(i).Set(valPtrV)
		} else {
			errs = append(errs, fmt.Errorf("error parsing %s: %v", section, err))
		}
	}
	return warn, errs
}
